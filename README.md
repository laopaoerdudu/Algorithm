### 跳表

这种链表加多级索引的结构，就是跳表。

跳表使用空间换时间的设计思路，通过构建多级索引来提高查询的效率，实现了基于链表的“二分查找”。跳表是一种动态数据结构，支持快速地插入、删除、查找操作，时间复杂度都是 O(logn)。

跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。

### 散列表

如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)？

>但是在真实的情况下，要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的。
即便像业界著名的 MD5、SHA、CRC 等哈希算法，也无法完全避免这种散列冲突。
而且，因为数组的存储空间有限，也会加大散列冲突的概率。

**散列冲突**

我们常用的散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining）。

>当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。

散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。
散列表两个核心问题是散列函数设计和散列冲突解决。散列冲突有两种常用的解决方法，开放寻址法和链表法。
散列函数设计的好坏决定了散列冲突的概率，也就决定散列表的性能。

### 如何设计散列函数？

散列函数生成的值要尽可能随机并且均匀分布，这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。

如何实现这样一个散列表呢？根据前面讲到的知识，我会从这三个方面来考虑设计思路：

1，设计一个合适的散列函数；

2，定义装载因子阈值，并且设计动态扩容策略；

3，选择合适的散列冲突解决方法。

>但是，对于小规模数据、装载因子不高的散列表，比较适合用开放寻址法。

实际上 LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的 “Linked” 实际上是指的是双向链表，并非指用链表法解决散列冲突。

### 为什么散列表和链表经常一块使用？

散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。
也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历。

因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。
为了解决这个问题，我们将散列表和链表（或者跳表）结合在一起使用。

### 什么是哈希算法？

将 任意长度 的二进制值串映射为 固定长度 的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。

我总结了需要满足的几点要求：

- 从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；

- 对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；

- 散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；

- 哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。

即便哈希算法存在冲突，但是在有限的时间和资源下，哈希算法还是很难被破解的。

哈希算法有一个特点，对数据很敏感。只要文件块的内容有一丁点儿的改变，最后计算出的哈希值就会完全不同。
























