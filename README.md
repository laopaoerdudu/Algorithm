### 队列

如何理解“队列”？队列这个概念非常好理解。你可以把它想象成排队买票，先来的先买，后来的人只能站末尾，不允许插队。先进者先出，这就是典型的“队列”。

队列最基本的操作也是两个：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。

跟栈一样，队列可以用数组来实现，也可以用链表来实现。

- 用数组来实现队列

- 用链表来实现队列

对于栈来说，我们只需要一个栈顶指针就可以了。

但是队列需要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向队尾。

你肯定已经发现了，随着不停地进行入队、出队操作，head 和 tail 都会持续往后移动。
当 tail 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。这个问题该如何解决呢？

用数据搬移！！！

如果没有空闲空间了，我们只需要在入队时，再集中触发一次数据的搬移操作。
借助这个思想，出队函数 dequeue() 保持不变，我们稍加改造一下入队函数 enqueue() 的实现，就可以轻松解决刚才的问题了。

### 循环队列

原本数组是有头有尾的，是一条直线。现在我们把首尾相连，扳成了一个环。

要想写出没有 bug 的循环队列的实现代码，我个人觉得，最关键的是，确定好队空和队满的判定条件。

那针对循环队列，如何判断队空和队满呢？

- 队列为空的判断条件仍然是 head == tail

- 当队满时，(tail + 1) % capacity = head

- 当队列满时，图中的 tail 指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间

### 阻塞队列和并发队列

`阻塞队列` 其实就是在队列基础上增加了阻塞操作。

简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；

如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。

线程安全的队列我们叫做并发队列。

最简单直接的实现方式是直接在 `enqueue()`，`dequeue()` 方法上加锁、但是锁粒度并发度会比较低，同一时刻仅允许一个存或者取操作。

实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高的并发队列。

我们希望公平地处理每个排队的请求，先进者先服务，所以 队列 这种数据结构很适合来存储 排队请求。

对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过 `队列` 这种数据结构来实现请求排队。

### 设计循环双端队列？





























